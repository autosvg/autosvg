= AutoSVG

TODO présentation équipe

Tom Etienne

Achraf Hassani

Yacine Hmito

Thibaut Quentin

== Dessiner un automate

Image d'automate en bitmap
Image d'automate en vectoriel

[.cue]
****
- Dessin != Automate, ce n'est rien qu'une représentation
  * De l'encre sur du papier
  * Une matrice de pixels
  * Des primitives de dessin vectoriel
- Motiver le choix du vectoriel
  * C'est le meilleur format d'image pour un dessin (pas de perte de qualité mais léger)
****

== Des représentations exactes d'automate

TODO d'un côté un automate en "Mathématique", de l'autre avec notre langage

[.cue]
****
- Automate == Représentation mathématique, mais
- Motiver le fait de vouloir dessiner facilement
  * Les maths c'est nul
- Motiver la création d'un langage simple et concis
  * Les maths, pas une façon réaliste de le saisir dans une application
****

== Le Web

- Facile d'accès
- Environnement graphique
- Expérimenter

[.cue]
****
- Le Web, déploiement facile, portable, pas d'installation
- La possibilité de faire des choses stylées graphiquement
- Preuve de concept pour relancer projet de recherche
****

== Notre objectif

Mettre en oeuvre une application de représentation d'automate à l'aide
des technologies Web.

[.cue]
****
- Motiver le choix d'un langage
  * Dessin != automate
- Motiver l'utilisation du Web
  * On veut mettre à l'épreuve les technologies Web
  * Preuve de concept pour relancer un projet de recherche
  * Pour les étudiants c'est plus facile à utiliser (question de déploiement)

Notre projet, réponse à cette requête de M. Nicart
****

== Plan

. Un cahier des charge bien rempli
. Une application modulaire
. Organisation
. Bilan
. Démo

[.cue]
****
Motiver le projet par les demandes du client:
- Dessiner des automates en SVG
- Depuis un langage à définir
- Dans un navigateur côté client
****

== Cahier des charges

Elaboré avec le "client"

[.cue]
****
- Réunion avec le client => Cahier des charges
- Nous étions force de proposition
- Il y a des fonctionnalités qui sont issues de la demande de M. Nicart
tandis que d'autres sont de notre initiative
****

== Fonctionnalités attendues

- Une représentation textuelle
  * Donc un langage à définir : CAL
- Une représentation graphique
  * Vectoriel dans le navigateur = SVG

[.cue]
****
* Une vue = zone de saisie pour une description textuelle de l'automate
  - dans un langage simple défini durant la première phase du projet
  - CAL, concise automaton language
* Une autre vue = représentation graphique
  - en SVG
* Deux vues d'un même modèle dans le cadre d'un patron de conception MVC
****

== Représentations

[source, cal]
----
fa {
  states {
    0[initial terminal]
  }
  transitions {
    0 a -> 1
    1 b -> 0
  }
}
----

++++
<script src="vendor.js"></script>
<script src="app.js"></script>
<div id="reprecal"></div>
<script>
require("app/render").default(
 "fa { states { 0[initial terminal] } transitions { 0 a -> 1 1 b -> 0 } }",
  "#reprecal"
);
var d3 = require("d3");
d3.select(document.getElementById("reprecal").childNodes[0])
.select("g").attr("transform", "scale(2)");
</script>
++++

[.cue]
****
- A gauche, CAL, à droite SVG
- CAL = "bon" langage, c.a.d. intuitif et concis
- Le dessin ressemble à ce qu'on attend
****

== Fonctionnalités supplémentaires

- Positionnement automatique des entités
- Mécanisme d'inférence
- Signalisation des erreurs
- Customisation de styles

[.cue]
****
- Expliquer en quoi chacune des fonctionnalités aide à remplir la tâche
qui nous a été confiée
  . Concision
  . Concision
  . Intuition
  . Pédagogie
****

== Fonctionnalités non implémentées

- Quelques opérations sur les automates
- Fonction d'export du SVG
- Altérer l'automate depuis la vue graphique
- Mettre à jour la vue texte

[.cue]
****
- On les as proposé mais on ne les a pas faites
****

== Architecture

3 composants: Langage, Modèle, Dessin (évident) +
Modèle: 2 couches (pour les algos) +
Protocoles, API +
Bibliothèques:

PEJGS:: Parsing
Dagre:: Layout
D3:: DOM SVG

ES2015

Motiver les choix par le cahier des charges (entre autres)

== Organisation

== Outils

- Brunch (modules et transpilation)
- NPM (dépendences)
- Git (version, partage)
- Google Hangouts (communication)


== Equipes

- L'architecture qui oriente le choix en travail en 2 équipes
- Le modèle est la frontière: on définit une API et un protocole, puis

Parseur, gestion des erreurs :

- Thibaut
- Achraf

Implémentation du modèle, dessin :

- Yacine
- Tom

== Rencontres

Rencontres hedbomadaires physiques entre nous (Bilan)

Recontres hebdomadaires avec le tuteur

Intention de faire du déploiement continu

== Bilan

Version fonctionnelle en ligne, cas d'utilisation principaux implémentés

== Technique

Fonctionnalités non développées:

- GUI: titanesque parce que architecture pas aboutie
- Retour sur le langage (lié à GUI)
- Export: pas considéré comme prioritaire
- Algos: ?

Le reste nous a pris bcp de tmps

Ecosystème du Web satisfaisant
Technologie SVG satisfaisante
Problème d'expressivité et de robustesse en JS

== Organisation

Plus incrémental, plus de tests
Déploiement continu suppose intégration continue, et ça a pêché

== Humain

Motivation en col, notamment dû au manque incrémental
Télétravail excellent
(TBC)

== Démo

1. Un automate normal sans inférence
- montre la simplicité du langage
- le positionnement automatique
- tout est attendu

2. Inférence
- le langage est concis

3. Placement manuel

4. Style

5. Signalisation des erreurs

6? Un exemple avec un professeur
