== Bilan

=== Technique

Certaines fonctionnalités n'ont pas été implémentées. Il a en en effet fallu prioriser les fonctionnalités et nous nous sommes focalisés sur le cas d'utilisation principal.
L'application ne propose donc pas d'édition graphique. Cela aurait nécessiter
un effort trop conséquent pour aboutir à un résultat satisfaisant. De plus,
le modèle présente certains défauts d'implémentation qu'il aurait d'abord fallu corriger.
Il est cependant déjà possible de modifier la position des états par glisser-déposer.

Le changement de la vue texte à partir du modèle n'a pas été implémenté non plus. Cela est du au fait que, sans édition graphique, aucun changement ne peut subvenir dans le modèle.
Cette fonctionnalité n'aurait donc jamais servi.

Les fonctionnalités manquantes comme l'éxécution d'algorithmes sur les automates
ou l'export dans d'autres formats s'accomodent toutefois très bien de l'architecture.
Elles devraient être faciles à implémenter.

=== Retour d'expérience

Notre tuteur était particulièrement intéressé par notre expérience avec les
technologies Web. Voici nos conclusions.

==== Un ecosystème riche

L'utilisation des technologies Web durant ce projet a donné accés à un écosystème très riche.
C'est de cet écosystème que sont issues les principales dépendances du projet : D3, PEGjs et Dagre. Toutefois cette richesse peut s'avérer problématique. Il est parfois difficile de faire un choix
puisqu'il évaluer les solutions disponibles.

Bien que les technologies Web côté client évoluent relativement lentement,
les outils à disposition des développeurs sont nombreux et matures.
L'environnement de développement que nous avons pu mettre en place en témoigne.

==== Un langage parfois handicapant

Le langage Javascript présente certains avantages.
La manipulation aisée des fonctions permet de changer le comportements des objets durant l'éxécution.
Cela facilite l'utilisation de techniques de programmation avancée tels que les mixins, le patron de conception de fabrique abstraite ou la métaprogrammation.

Malgrè cela, le Javascript souffre de certains inconvénients, notamment l'absence de typage.
En conséquence, une partie conséquente du code est consacrée au travail de vérification afin
de ne pas fragiliser l'application. Le code est aussi moins lisible.
De plus, aucun compilateur ne peut venir en aide au programmeur pour prévenir certaines
erreurs triviales. Sans une batterie de tests automatisés (qu'il faut également programmer),
les bugs sont fréquents et viennent impacter la productivité.

Il est difficile et/ou peu efficace d'isoler des variables en Javascript car le langage
ne propose pas d'attributs privés. Cela a rendu l'implémentation du modèle plus difficile ;
la lisibilité du code en a donc été impactée.

Lors de l'implémentation des fonctions de dessin, nous aurions aimer pouvoir définir
des fonction en notation infixe. Les portions du code relatives à la manipulation
de vecteurs auraient été bien plus lisibles.

Le fait que la dernière version de Javascript ne soit pas intégralement implémentée par tous les navigateurs peut nuire à la compatibilité. Transpilateurs et polyfills mitigent ce problème.
Naturellement, nous ne pouvons espérer des performances similaires à des langages compilés.

==== Une interface souple

Pour la programmation d'interfaces graphiques en dehors des applications Web,
les développeurs doivent jongler entre des API très haut niveau et des API plutôt bas niveau.
D'un côté, les API haut niveau permettent la création rapide de composants, mais ceux-ci présentent
des formes et des comportement rigides.
De l'autre côté, les API bas niveau n'ont de limite que l'imagination du développeur,
mais au prix d'un effort de programmation très conséquent.

Malgré ses défauts, l'environnement graphique du navigateur nous semble 
atteindre le parfait compromis. Grâce au DOM et au CSS, il est facile de
concevoir une vue, de la styliser et d'y enregistrer des écouteurs.
Nous ne sommes toutefois pas cantonnés à des composants limités.
Les boîtes à outils GTK3 et Qt5 tentent d'ailleurs de s'inspirer de ces
technologies Web pour proposer les mêmes avantages.

=== Humain

Nous avons remis en question nos choix pour l'application pendant trop longtemps. Il aurait été plus sage de commencer à développer plus tôt pour s'apercevoir des éventuelles problèmes à l'utilisation.
Cela nous a d'ailleurs empéché de faire un véritable déploiement continu, puisque nous ne codions pas toujours, nous n'avions aucune nouvelle fonctionnalité à intégrer.
Il aurait été bien de faire plus de tests pour faciliter l'intégration mais aussi compenser les faiblesses de Javascript. Cela aurait été aussi bénéfique pour définir notre API. En effet, les besoins seraient apparus plus rapidement.

=== Perspectives 

La réalisation de ce projet laisse entrevoir différentes améliorations possibles. 

Finaliser l'édition graphique requiert de revisiter la relation entre le modèle
et l'algorithme de calcul des positions. Ils nous semblent pour le moment trop
couplés, bien que des progrès ait déjà été effectués en ce sens. A terme, on souhaiterait pouvoir spécifier dynamiquement l'algorithme de positonnement
automatique.

Après avoir utilisé le langage CAL sur nos exemples, nous nous sommes rendus compte qu'il est possible de le rendre plus concis encore. En effet, il est naturel de spécifier ensemble des transitions
qui partagent les mêmes états de départ et d'arrivée.

Cela réglerait également le problème de positionnement des arcs, moyennant la définition
de règles de précédence entre les transitions partageant le même arc.

La partie de dessin gagnerait également à définir des classes pour chaque type d'entité
à dessiner. Ces composants seraient alors responsables de leur propre rendu et d'enregister
leur écouteurs auprès du modèle.
Pour l'heure, les fonctions de dessin sont codées dans un style très procédural.

Enfin, si le projet était à refaire, nous nous orienterons probablement vers
un langage fonctionnel fortement typé. Un certain nombre propose des transpilateurs
Javascript, comme PureScript, Elm ou Haskell.
