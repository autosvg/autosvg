== Bilan

=== Technique

Certaines fonctionnalités n'ont toutefois pas été implémentées. Il a en en effet fallu prioriser les différentes tâches à effectuer et nous nous sommes focalisés sur le cas d'utilisation principal.
C'est le cas de l'édition graphique, la raison étant que cette fonctionnalité nécéssite des changements dans le modèle.
Le changement de la vue texte à partir du modèle n'a pas été implémenté non plus. Cela est du au fait que sans édition graphique aucun changement ne surviendra dans le modèle rendant cette fonctionnalité inintéréssante.
Toutefois l'architecture du modèle permet de l'étendre aisément en proposant les fonctionnalités manquant comme la gestion des algorithmes ou l'export dans d'autres formats.

=== Retour d'expérience

// TODO une petite intro

== Un ecosystème riche

L'utilisation des technologies Web durant ce projet a donné accés à un écosystème très riche.
C'est de cet écosystème que sont issues les principales dépendances du projet : D3, PEGjs et Dagre. Toutefois cette richesse peut s'avérer problèmatique. Il est parfois difficile de faire un choix
puisqu'il évaluer les solutions disponibles.

== Un langage parfois handicapant

Le langage Javascript présente certains avantages.
La manipulation aisée des fonctions permet de changer le comportements des objets durant l'éxécution.
Cela facilite facilite l'utilisation de techniques de programmation avancée tels que les mixins, le patron de conception de fabrique abstraite ou la métaprogrammation.

Malgrè cela, le Javascript souffre de certains inconvénients, notamment l'absence de typage.
En conséquence, une partie conséquente du code est consacrée au travail de vérification afin
de pas fragiliser l'application. Le code est aussi moins lisibile.
De plus, aucun compilateur ne peut venir en aide au programmeur pour prévenir certaines
erreures triviales. Sans une batterie de tests automatisés (qu'il faut également programmer),
les bugs sont fréquents et viennent impacter la productivité.

Il est difficile et/ou peu efficace d'isoler des variables en Javascript car le langage
ne propose pas d'attributs privés. Cela a rendu l'implémentation du modèle plus difficile ;
la lisibilité du code en a donc été impactée.

Lors de l'implémentation des fonctions de dessin, nous aurions aimer pouvoir définir
des fonction en notation infixe. Les portions du code relatives à la manipulation
de vecteurs auraient été bien plus lisibles.

Le fait que la dernière version de Javascript ne soit pas intégralement implémentée par tous les navigateurs peut nuire à la compatibilité. Transpilateurs et polyfills mitigent ce problème.
Naturellement, nous ne pouvons espérer des performances similaires à des langages compilés.

=== Humain

Nous avons remis en question nos choix pour l'application pendant trop longtemps. Il aurait été plus sage de commencer à développer plus tôt pour s'apercevoir des éventuelles problèmes à l'utilisation.
Cela nous a d'ailleurs empéché de faire un véritable déploiement continu, puisque nous ne codions pas toujours, nous n'avions aucune nouvelle fonctionnalité à intégrer.
Il aurait été bien de faire plus de tests pour faciliter l'intégration mais aussi compenser les faiblesses de Javascript. Cela aurait été aussi bénéfique pour définir notre API. En effet, les besoins seraient apparus plus rapidement.

=== Perspectives 

La réalisation de ce projet laisse entrevoir différentes améliorations possibles. 

Finaliser l'édition graphique requiert de revisiter la relation entre le modèle
et l'algorithme de calcul des positions. Ils nous semblent pour le moment trop
couplés, bien que des progrès ait déjà été effectués en ce sens. A terme, on souhaiterait pouvoir spécifier dynamiquement l'algorithme de positonnement
automatique.

Après avoir utilisé le langage CAL sur nos exemples, nous nous sommes rendus compte qu'il est possible de le rendre plus concis encore. En effet, il est naturel de spécifier ensemble des transitions
qui partagent les mêmes états de départ et d'arrivée.

Cela réglerait également le problème de positionnement des arcs, moyennant la définition
de règles de précédence entre les transitions partageant le même arc.

La partie de dessin gagnerait également à définir des classes pour chaque type d'entité
à dessiner. Ces composants seraient alors responsables de leur propre rendu et d'enregister
leur écouteurs auprès du modèle.
Pour l'heure, les fonctions de dessin sont codées dans un style très procédural.

Enfin, si le projet était à refaire, nous nous orienterons probablement vers
un langage fonctionnel fortement typé. Un certain nombre propose des transpilateurs
Javascript, comme PureScript, Elm ou Haskell.
